package org.KonohaScript.CodeGen;

import org.KonohaScript.KClass;
import org.KonohaScript.KMethod;
import org.KonohaScript.KNameSpace;

/****************************************************************************
 * Copyright (c) 2012-2013, Masahiro Ide <ide@konohascript.org> All rights
 * reserved. Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. * Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ***************************************************************************/

enum VMState {
	Continue,
	Exit
}

class KonohaIR {
	void dump() {
	}

	VMState exec(Object[] Registers, Object[] Stack) {
		return VMState.Exit;
	}

	public static void dump0(String OP) {
	}

	public static void dump1(String OP, String A1Ty, Object A1) {
	}

	public static void dump2(String OP, String A1Ty, Object A1, String A2Ty, Object A2) {
	}

	public static void dump3(String OP, String A1Ty, Object A1, String A2Ty, Object A2, String A3Ty, Object A3) {
	}

	public static void dump4(String OP, String A1Ty, Object A1, String A2Ty, Object A2, String A3Ty, Object A3, String A4Ty, Object A4) {
	}
}

class LineInfo {
	int	FileSymbol;
	int	LineNumber;
}

class KTraceFunc {
	KTraceFunc() {
	}
}

public class KonohaVM {

	public KonohaVM() {
	}

	void Exec(KonohaIR[] Code) {
		Object[] Registers = new Object[10];
		Object[] Stack = new Object[10];
		for (int i = 0; i < Code.length; i++) {
			KonohaIR ir = Code[i];
			VMState state = ir.exec(Registers, Stack);
			if (state == VMState.Exit) {
				break;
			}
		}
	}
}

/* This file was automatically generated by GenLIR.k. Do not edit! */
// #define OPCODE_LoadConst 0
class OPLoadConst extends KonohaIR {
	int					Dst;
	int					Value;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_LoadConst	= 3;

	@Override
	void dump() {
		KonohaIR.dump3("LoadConst", "int", this.Dst, "int", this.Value, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		int Value = this.Value;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_Move 1
class OPMove extends KonohaIR {
	int					Dst;
	int					Src;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_Move	= 3;

	@Override
	void dump() {
		KonohaIR.dump3("Move", "int", this.Dst, "int", this.Src, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		int Src = this.Src;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_LoadField 2
class OPLoadField extends KonohaIR {
	int					Dst;
	int					Src;
	int					Offset;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_LoadField	= 4;

	@Override
	void dump() {
		KonohaIR.dump4("LoadField", "int", this.Dst, "int", this.Src, "int", this.Offset, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		int Src = this.Src;
		int Offset = this.Offset;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_StoreField 3
class OPStoreField extends KonohaIR {
	int					Dst;
	int					Offset;
	int					Src;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_StoreField	= 4;

	@Override
	void dump() {
		KonohaIR.dump4("StoreField", "int", this.Dst, "int", this.Offset, "int", this.Src, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		int Offset = this.Offset;
		int Src = this.Src;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_New 4
class OPNew extends KonohaIR {
	int					Dst;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_New	= 2;

	@Override
	void dump() {
		KonohaIR.dump2("New", "int", this.Dst, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_Null 5
class OPNull extends KonohaIR {
	int					Dst;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_Null	= 2;

	@Override
	void dump() {
		KonohaIR.dump2("Null", "int", this.Dst, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_Box 6
class OPBox extends KonohaIR {
	int					Dst;
	int					Src;
	KClass				TypeInfo;
	static final int	OPFIELDSIZE_Box	= 3;

	public OPBox(KonohaIR e) {
	}

	@Override
	void dump() {
		KonohaIR.dump3("Box", "int", this.Dst, "int", this.Src, "KClass", this.TypeInfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		int Src = this.Src;
		KClass TypeInfo = this.TypeInfo;
		return VMState.Exit;
	}
}

// #define OPCODE_Lookup 7
class OPLookup extends KonohaIR {
	int					Dst;
	KNameSpace			NS;
	KMethod				Mtd;
	KClass				ThisType;
	static final int	OPFIELDSIZE_Lookup	= 4;

	@Override
	void dump() {
		KonohaIR.dump4("Lookup", "int", this.Dst, "KNameSpace", this.NS, "KMethod", this.Mtd, "KClass", this.ThisType);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		KNameSpace NS = this.NS;
		KMethod Mtd = this.Mtd;
		KClass ThisType = this.ThisType;
		return VMState.Exit;
	}
}

// #define OPCODE_Call 8
class OPCall extends KonohaIR {
	int					Dst;
	KNameSpace			NS;
	KMethod				Mtd;
	KClass				ThisType;
	static final int	OPFIELDSIZE_Call	= 4;

	@Override
	void dump() {
		KonohaIR.dump4("Call", "int", this.Dst, "KNameSpace", this.NS, "KMethod", this.Mtd, "KClass", this.ThisType);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		KNameSpace NS = this.NS;
		KMethod Mtd = this.Mtd;
		KClass ThisType = this.ThisType;
		return VMState.Exit;
	}
}

// #define OPCODE_Ret 9
class OPRet extends KonohaIR {
	static final int	OPFIELDSIZE_Ret	= 0;

	@Override
	void dump() {
		KonohaIR.dump0("Ret");
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		return VMState.Exit;
	}
}

// #define OPCODE_BNot 10
class OPBNot extends KonohaIR {
	int					Dst;
	int					Src;
	static final int	OPFIELDSIZE_BNot	= 2;

	@Override
	void dump() {
		KonohaIR.dump2("BNot", "int", this.Dst, "int", this.Src);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Dst = this.Dst;
		int Src = this.Src;
		return VMState.Exit;
	}
}

// #define OPCODE_Jump 11
class OPJump extends KonohaIR {
	int					Address;
	static final int	OPFIELDSIZE_Jump	= 1;

	@Override
	void dump() {
		KonohaIR.dump1("Jump", "int", this.Address);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Address = this.Address;
		return VMState.Exit;
	}
}

// #define OPCODE_JumpF 12
class OPJumpF extends KonohaIR {
	int					Address;
	int					Src;
	static final int	OPFIELDSIZE_JumpF	= 2;

	@Override
	void dump() {
		KonohaIR.dump2("JumpF", "int", this.Address, "int", this.Src);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Address = this.Address;
		int Src = this.Src;
		return VMState.Exit;
	}
}

// #define OPCODE_Try 13
class OPTry extends KonohaIR {
	int					Address;
	static final int	OPFIELDSIZE_Try	= 1;

	@Override
	void dump() {
		KonohaIR.dump1("Try", "int", this.Address);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		int Address = this.Address;
		return VMState.Exit;
	}
}

// #define OPCODE_Yield 14
class OPYield extends KonohaIR {
	static final int	OPFIELDSIZE_Yield	= 0;

	@Override
	void dump() {
		KonohaIR.dump0("Yield");
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		return VMState.Exit;
	}
}

// #define OPCODE_Error 15
class OPError extends KonohaIR {
	String				ErrorMessage;
	static final int	OPFIELDSIZE_Error	= 1;

	@Override
	void dump() {
		KonohaIR.dump1("Error", "String", this.ErrorMessage);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		String ErrorMessage = this.ErrorMessage;
		return VMState.Exit;
	}
}

// #define OPCODE_SafePoint 16
class OPSafePoint extends KonohaIR {
	LineInfo			linfo;
	int					StackTop;
	static final int	OPFIELDSIZE_SafePoint	= 2;

	@Override
	void dump() {
		KonohaIR.dump2("SafePoint", "LineInfo", this.linfo, "int", this.StackTop);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		LineInfo linfo = this.linfo;
		int StackTop = this.StackTop;
		return VMState.Exit;
	}
}

// #define OPCODE_CheckStack 17
class OPCheckStack extends KonohaIR {
	LineInfo			linfo;
	static final int	OPFIELDSIZE_CheckStack	= 1;

	@Override
	void dump() {
		KonohaIR.dump1("CheckStack", "LineInfo", this.linfo);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		LineInfo linfo = this.linfo;
		return VMState.Exit;
	}
}

// #define OPCODE_Trace 18
class OPTrace extends KonohaIR {
	LineInfo			linfo;
	int					StackTop;
	KTraceFunc			KFunc;
	static final int	OPFIELDSIZE_Trace	= 3;

	@Override
	void dump() {
		KonohaIR.dump3("Trace", "LineInfo", this.linfo, "int", this.StackTop, "TraceFunc", this.KFunc);
	}

	@Override
	VMState exec(Object[] Regs, Object[] Stack) {
		LineInfo linfo = this.linfo;
		int StackTop = this.StackTop;
		KTraceFunc KFunc = this.KFunc;
		return VMState.Exit;
	}
}
